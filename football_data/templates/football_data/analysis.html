{% extends 'base.html' %}
{% load static %}

{% block title %}An√°lisis de Partidos - Predicciones Completas{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/football_data/analysis.css' %}">
<style>
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    }
    
    .loading-spinner {
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    .spinner {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        font-size: 18px;
        color: #333;
        font-weight: bold;
    }
    
    .loading-text-progress {
        font-size: 14px;
        color: #666;
        margin-top: 10px;
    }
    
    .prediction-badge {
        font-size: 13px;
        padding: 5px 10px;
        font-weight: 600;
    }
    
    .table-responsive {
        max-height: 800px;
        overflow-y: auto;
    }
</style>
{% endblock %}

{% block content %}
<!-- Loading Overlay -->
<div id="loading-overlay" class="loading-overlay" style="display: flex;">
    <div class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">Cargando predicciones...</div>
        <div class="loading-text-progress" id="loading-progress">Iniciando an√°lisis...</div>
    </div>
</div>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <div>
                    <h1 class="text-primary"><i class="fas fa-chart-line"></i> An√°lisis Completo de Predicciones</h1>
                    <p class="text-muted mb-0">An√°lisis multi-modelo para los pr√≥ximos 24 horas</p>
                </div>
                <div class="text-end">
                    <span class="badge bg-success">
                        <i class="fas fa-sync-alt"></i> Actualizado: <span id="updated-time">{{ updated_at|date:"H:i" }}</span>
                    </span>
                    <p class="text-muted small mb-0 mt-2">Total partidos: <strong id="total-matches">0</strong> / <span id="total-available">-</span></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Informaci√≥n de Colores -->
    <div class="row mb-3">
        <div class="col-12">
            <div class="alert alert-info d-flex align-items-center">
                <i class="fas fa-info-circle me-2"></i>
                <div>
                    <strong>Leyenda de Colores (Ambos Marcan):</strong>
                    <span class="badge bg-success ms-2">Verde: ‚â•60% (Alta probabilidad)</span>
                    <span class="badge bg-warning ms-2">Amarillo: 40-59% (Probabilidad media)</span>
                    <span class="badge bg-danger ms-2">Rojo: <40% (Baja probabilidad)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Tabla de Partidos (siempre visible; se llena din√°micamente) -->
    <div class="row">
        <div class="col-12">
            <div class="card shadow">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-futbol"></i> Partidos de las Pr√≥ximas 24 Horas</h5>
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead class="table-light" style="position: sticky; top: 0; z-index: 10;">
                                <tr>
                                    <th>Liga</th>
                                    <th>Local</th>
                                    <th>Visitante</th>
                                    <th>Fecha</th>
                                    <th>Hora (CO)</th>
                                    <th class="text-center">Remates Total</th>
                                    <th class="text-center">Remates Local</th>
                                    <th class="text-center">Remates Visit.</th>
                                    <th class="text-center">Remates a Puerta</th>
                                    <th class="text-center">Goles Total</th>
                                    <th class="text-center">Goles Local</th>
                                    <th class="text-center">Goles Visit.</th>
                                    <th class="text-center">Corners Total</th>
                                    <th class="text-center">Corners Local</th>
                                    <th class="text-center">Corners Visit.</th>
                                    <th class="text-center">Ambos Marcan</th>
                                </tr>
                            </thead>
                            <tbody id="matches-tbody">
                                <!-- Las filas se cargar√°n din√°micamente v√≠a AJAX -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Informaci√≥n Adicional -->
    <div class="row mt-4">
        <div class="col-md-4">
            <div class="card bg-light">
                <div class="card-body text-center">
                    <i class="fas fa-cogs fa-2x text-primary mb-2"></i>
                    <h6>Modelo Utilizado</h6>
                    <p class="small text-muted mb-0">Predicci√≥n Oficial (Ensemble Multi-Modelo)</p>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card bg-light">
                <div class="card-body text-center">
                    <i class="fas fa-sync-alt fa-2x text-success mb-2"></i>
                    <h6>Actualizaci√≥n Autom√°tica</h6>
                    <p class="small text-muted mb-0">Los datos se actualizan al cargar la p√°gina</p>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card bg-light">
                <div class="card-body text-center">
                    <i class="fas fa-clock fa-2x text-warning mb-2"></i>
                    <h6>Zona Horaria</h6>
                    <p class="small text-muted mb-0">Hora en Colombia (UTC-5)</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingProgress = document.getElementById('loading-progress');
    const matchesTbody = document.getElementById('matches-tbody');
    const totalMatchesEl = document.getElementById('total-matches');
    const totalAvailableEl = document.getElementById('total-available');
    const updatedTimeEl = document.getElementById('updated-time');
    
    let currentOffset = 0;
    let totalAvailable = 0;
    let allProcessedMatches = [];
    const batch_size = 3;  // Tama√±o del lote para procesamiento
    let isLoading = false;  // Prevenir m√∫ltiples requests simult√°neos
    
    // Funci√≥n para agregar una fila a la tabla
    function addMatchRow(match) {
        const row = document.createElement('tr');
        
        // Funci√≥n helper para formatear predicci√≥n
        function formatPrediction(pred) {
            if (!pred || pred === null || pred === undefined) return '<span class="text-muted">-</span>';
            const value = typeof pred === 'object' && pred.prediction !== undefined ? pred.prediction : pred;
            return `<span class="badge bg-info prediction-badge">${parseFloat(value).toFixed(1)}</span>`;
        }
        
        // Funci√≥n helper para badges de goles
        function formatGoalPrediction(pred) {
            if (!pred || pred === null || pred === undefined) return '<span class="text-muted">-</span>';
            const value = typeof pred === 'object' && pred.prediction !== undefined ? pred.prediction : pred;
            return `<span class="badge bg-success prediction-badge">${parseFloat(value).toFixed(1)}</span>`;
        }
        
        // Funci√≥n helper para badges de corners
        function formatCornerPrediction(pred) {
            if (!pred || pred === null || pred === undefined) return '<span class="text-muted">-</span>';
            const value = typeof pred === 'object' && pred.prediction !== undefined ? pred.prediction : pred;
            return `<span class="badge bg-warning prediction-badge">${parseFloat(value).toFixed(1)}</span>`;
        }
        
        // Funci√≥n helper para ambos marcan
        function formatBothTeamsScore(pct) {
            if (pct === null || pct === undefined) return '<span class="text-muted">-</span>';
            const value = parseFloat(pct);
            let badgeClass = 'bg-danger';
            if (value >= 60) badgeClass = 'bg-success';
            else if (value >= 40) badgeClass = 'bg-warning';
            return `<span class="badge ${badgeClass} fs-6">${value.toFixed(1)}%</span>`;
        }
        
        const predictions = match.predictions || {};
        
        row.innerHTML = `
            <td><span class="badge bg-secondary">${match.league || '-'}</span></td>
            <td><strong>${match.home_team || '-'}</strong></td>
            <td><strong>${match.away_team || '-'}</strong></td>
            <td>${match.date || '-'}</td>
            <td><i class="fas fa-clock text-primary"></i> ${match.time || '-'}</td>
            <td class="text-center">${formatPrediction(predictions.shots_total)}</td>
            <td class="text-center">${formatPrediction(predictions.shots_home)}</td>
            <td class="text-center">${formatPrediction(predictions.shots_away)}</td>
            <td class="text-center">${formatPrediction(predictions.shots_on_target_total)}</td>
            <td class="text-center">${formatGoalPrediction(predictions.goals_total)}</td>
            <td class="text-center">${formatGoalPrediction(predictions.goals_home)}</td>
            <td class="text-center">${formatGoalPrediction(predictions.goals_away)}</td>
            <td class="text-center">${formatCornerPrediction(predictions.corners_total)}</td>
            <td class="text-center">${formatCornerPrediction(predictions.corners_home)}</td>
            <td class="text-center">${formatCornerPrediction(predictions.corners_away)}</td>
            <td class="text-center">${formatBothTeamsScore(match.prediction)}</td>
        `;
        
        matchesTbody.appendChild(row);
    }
    
    // Helper: fetch con timeout y reintentos, enviando cookies de sesi√≥n
    function fetchWithRetry(url, options = {}, retries = 2, timeoutMs = 60000) {  // Aumentado a 60 segundos
        return new Promise((resolve, reject) => {
            const controller = new AbortController();
            let timer = null;
            let isAborted = false;
            
            // Solo abortar si realmente se excede el timeout
            timer = setTimeout(() => {
                if (!isAborted) {
                    console.warn(`‚è± Timeout de ${timeoutMs}ms alcanzado para: ${url}`);
                    isAborted = true;
                    controller.abort();
                }
            }, timeoutMs);
            
            console.log(`üì° Iniciando fetch: ${url} (timeout: ${timeoutMs}ms, reintentos: ${retries})`);
            
            fetch(url, {
                ...options,
                credentials: 'same-origin',
                headers: { 'Accept': 'application/json', ...(options.headers || {}) },
                signal: controller.signal,
            })
            .then(resp => {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                
                console.log(`‚úì Respuesta recibida: ${resp.status} ${resp.statusText} para ${url}`);
                
                // Si est√° redirigiendo (por login), forzar error para reintentar/avisar
                if (!resp.ok || resp.redirected) {
                    const errorMsg = `HTTP ${resp.status}${resp.redirected ? ' (redirect)' : ''}`;
                    console.error(`‚ùå Error HTTP: ${errorMsg}`);
                    throw new Error(errorMsg);
                }
                
                return resp.json();
            })
            .then(data => {
                console.log(`‚úì JSON parseado exitosamente para ${url}`);
                resolve(data);
            })
            .catch(err => {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                
                // Detectar si fue abortado
                if (err.name === 'AbortError' || err.message.includes('aborted')) {
                    console.error(`‚ùå Request abortado: ${url}`, {
                        name: err.name,
                        message: err.message,
                        isAborted: isAborted
                    });
                    
                    if (!isAborted) {
                        // El abort fue manual o por otra raz√≥n, no por timeout
                        console.warn('‚ö† Abort no fue causado por timeout programado');
                    }
                } else {
                    console.error(`‚ùå Error en fetch: ${url}`, {
                        name: err.name,
                        message: err.message,
                        stack: err.stack
                    });
                }
                
                // Reintentar solo si no fue abortado
                if (retries > 0 && !isAborted) {
                    console.log(`üîÑ Reintentando (${retries} reintentos restantes)...`);
                    setTimeout(() => {
                        fetchWithRetry(url, options, retries - 1, timeoutMs).then(resolve).catch(reject);
                    }, 800);
                } else {
                    // Si fue abortado, mejorar el mensaje de error
                    if (isAborted) {
                        reject(new Error(`La solicitud excedi√≥ el tiempo l√≠mite de ${timeoutMs}ms. El servidor puede estar procesando muchos datos.`));
                    } else {
                        reject(err);
                    }
                }
            });
        });
    }

    // Funci√≥n para cargar el siguiente lote
    function loadNextBatch() {
        // Prevenir m√∫ltiples requests simult√°neos
        if (isLoading) {
            console.warn('‚ö† Ya hay una carga en progreso, ignorando solicitud duplicada');
            return;
        }
        
        isLoading = true;
        const progressText = totalAvailable > 0 
            ? `Procesando partidos... (${Math.min(currentOffset + 1, totalAvailable)}-${Math.min(currentOffset + 3, totalAvailable)} de ${totalAvailable})`
            : `Procesando partidos...`;
        loadingProgress.textContent = progressText;
        
        const cacheBust = `&_=${Date.now()}`;
        const url = '/football_data/analysis/ajax/?offset=' + currentOffset + '&batch_size=3' + cacheBust;
        console.log(`üîÑ Cargando lote desde offset ${currentOffset}`);
        
        fetchWithRetry(url)
            .then(data => {
                console.log('Respuesta recibida:', data);
                
                isLoading = false;  // Marcar carga como completada
                
                if (!data || typeof data !== 'object') {
                    console.error('‚ùå Respuesta inv√°lida:', data);
                    loadingProgress.textContent = '‚ùå Error: Respuesta inv√°lida del servidor';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 2000);
                    return;
                }
                
                if (data.success) {
                    // Actualizar total disponible si es la primera vez
                    if (totalAvailable === 0 && data.total > 0) {
                        totalAvailable = data.total;
                        totalAvailableEl.textContent = data.total;
                    }
                    
                    // Agregar partidos procesados
                    if (data.matches && Array.isArray(data.matches) && data.matches.length > 0) {
                        console.log(`‚úì Agregando ${data.matches.length} partidos al DOM`);
                        let addedCount = 0;
                        data.matches.forEach(match => {
                            if (match && match.home_team && match.away_team) {
                                const existing = allProcessedMatches.find(m => 
                                    m.league === match.league && 
                                    m.home_team === match.home_team && 
                                    m.away_team === match.away_team
                                );
                                if (!existing) {
                                    allProcessedMatches.push(match);
                                    addMatchRow(match);
                                    addedCount++;
                                } else {
                                    console.log(`Partido duplicado ignorado: ${match.home_team} vs ${match.away_team}`);
                                }
                            } else {
                                console.warn('Partido con datos incompletos:', match);
                            }
                        });
                        console.log(`‚úì ${addedCount} partidos nuevos agregados`);
                        
                        // Ordenar por fecha y hora
                        if (allProcessedMatches.length > 0) {
                            allProcessedMatches.sort((a, b) => {
                                const dateA = (a.date || '') + ' ' + (a.time || '');
                                const dateB = (b.date || '') + ' ' + (b.time || '');
                                return dateA.localeCompare(dateB);
                            });
                            
                            // Re-renderizar tabla ordenada
                            matchesTbody.innerHTML = '';
                            allProcessedMatches.forEach(match => {
                                try {
                                    addMatchRow(match);
                                } catch (err) {
                                    console.error('Error agregando fila:', err, match);
                                }
                            });
                        }
                        console.log(`‚úì Total partidos en tabla: ${allProcessedMatches.length}`);
                    } else {
                        console.warn(`‚ö† No se recibieron partidos en este lote (matches: ${data.matches ? data.matches.length : 'null'})`);
                    }
                    
                    // Actualizar contadores
                    totalMatchesEl.textContent = allProcessedMatches.length;
                    
                    // Actualizar offset: usar new_offset si est√° disponible, sino calcular
                    if (data.new_offset !== undefined && data.new_offset !== null) {
                        currentOffset = data.new_offset;
                    } else {
                        // Fallback: avanzar seg√∫n partidos intentados (processed_count puede ser menor si se descartan)
                        const attempted = data.attempted_count || data.processed_count || batch_size || 3;
                        currentOffset = (data.offset || 0) + attempted;
                    }
                    
                    console.log(`‚úì Lote procesado: ${data.matches ? data.matches.length : 0} recibidos, offset: ${data.offset} -> ${currentOffset}, has_more: ${data.has_more}, total: ${data.total}`);
                    
                    // Marcar carga como completada
                    isLoading = false;
                    
                    // Continuar si hay m√°s partidos
                    if (data.has_more === true && data.total > 0 && currentOffset < data.total) {
                        console.log(`‚Üí Continuando con siguiente lote desde offset ${currentOffset}`);
                        setTimeout(() => {
                            loadNextBatch();
                        }, 500); // Esperar 500ms antes del siguiente lote
                    } else {
                        console.log('‚úì Fin de carga:', {
                            has_more: data.has_more,
                            total: data.total,
                            currentOffset: currentOffset
                        });
                        // Termin√≥ la carga
                        if (allProcessedMatches.length === 0) {
                            loadingProgress.textContent = '‚ö†Ô∏è No se encontraron partidos disponibles';
                            setTimeout(() => {
                                loadingOverlay.style.display = 'none';
                                // Mostrar mensaje en la tabla
                                matchesTbody.innerHTML = `
                                    <tr>
                                        <td colspan="16" class="text-center py-5">
                                            <div class="alert alert-warning mb-0">
                                                <i class="fas fa-exclamation-triangle fa-2x mb-3"></i>
                                                <h5>No hay partidos disponibles</h5>
                                                <p class="mb-0">No se encontraron partidos programados para las pr√≥ximas 24 horas.</p>
                                            </div>
                                        </td>
                                    </tr>
                                `;
                            }, 1500);
                        } else {
                            loadingProgress.textContent = `‚úÖ Completado: ${allProcessedMatches.length} partidos procesados`;
                            setTimeout(() => {
                                loadingOverlay.style.display = 'none';
                                updatedTimeEl.textContent = new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                            }, 1000);
                        }
                    }
                } else {
                    // Error en respuesta
                    isLoading = false;
                    console.error('‚ùå Respuesta con success=false:', data);
                    const errorMsg = data.error || 'Error desconocido del servidor';
                    loadingProgress.textContent = `‚ùå Error: ${errorMsg}`;
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                        if (allProcessedMatches.length === 0) {
                            matchesTbody.innerHTML = `
                                <tr>
                                    <td colspan="16" class="text-center py-5">
                                        <div class="alert alert-danger mb-0">
                                            <i class="fas fa-exclamation-circle fa-2x mb-3"></i>
                                            <h5>Error al cargar partidos</h5>
                                            <p class="mb-0">${errorMsg}</p>
                                            <button class="btn btn-primary mt-3" onclick="location.reload()">
                                                <i class="fas fa-sync-alt"></i> Reintentar
                                            </button>
                                        </div>
                                    </td>
                                </tr>
                            `;
                        }
                    }, 2000);
                }
            })
            .catch(error => {
                isLoading = false;  // Marcar carga como completada (incluso si fall√≥)
                
                console.error('‚ùå Error en fetch:', error);
                console.error('Detalles del error:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack,
                    cause: error.cause
                });
                
                // Mejorar mensaje de error seg√∫n el tipo
                let errorMessage = error.message || 'Error desconocido al conectar con el servidor';
                if (error.message.includes('timeout') || error.message.includes('tiempo l√≠mite')) {
                    errorMessage = 'El servidor est√° tardando demasiado en procesar los datos. Intenta nuevamente o contacta al administrador.';
                } else if (error.message.includes('aborted') || error.name === 'AbortError') {
                    errorMessage = 'La solicitud fue cancelada. Esto puede deberse a que el servidor est√° procesando muchos datos. Intenta nuevamente.';
                }
                
                loadingProgress.textContent = `‚ùå Error: ${errorMessage}`;
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                    // Mostrar mensaje de error en la tabla
                    if (allProcessedMatches.length === 0) {
                        matchesTbody.innerHTML = `
                            <tr>
                                <td colspan="16" class="text-center py-5">
                                    <div class="alert alert-danger mb-0">
                                        <i class="fas fa-exclamation-circle fa-2x mb-3"></i>
                                        <h5>Error al cargar partidos</h5>
                                        <p class="mb-0">${errorMessage}</p>
                                        <button class="btn btn-primary mt-3" onclick="location.reload()">
                                            <i class="fas fa-sync-alt"></i> Reintentar
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }
                }, 2000);
            });
    }
    
    // Iniciar carga
    loadingOverlay.style.display = 'flex';
    loadNextBatch();
});
</script>
{% endblock %}
